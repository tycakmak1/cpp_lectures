# LECTURE 02

In C char constants are 4 bytes, but in C++(they are named character literals) they are 1 byte.<br>
In C `"jack"` is `char[5]`, 5 because it ends with `'\0'`, but in C++ it is `char const[5]`.<br>

_*Array decay - array to pointer conversion*_: meaning array names act as pointers, except in `sizeof()` in C.<br>
_*Unevaluated context*_, in C only happens in `sizeof`, but in C++ there are 7-8 instances.

For int `a[10]`;<br>
&nbsp;&nbsp;&nbsp;&nbsp;`a` &nbsp;&nbsp;has the type `int[10]` (also there is pointer decay)<br>
&nbsp;&nbsp;&nbsp;&nbsp;`&a` has the type `int (*)[10]`.

C++ also uses pointers but, compared to their usage in C it is much more sparse. Because C++ uses reference semantics, and we
use `smart_pointer`'s to control dynamic sizes. In some cases instead of using pointers, we use containers like
`vector<int>::iterator`.

In C char `str[4] = "jack"` is perfectly legal but does not have null character at the end.<br>
In C++ this is a syntax error, must be char `str[5] = "jack"`.

### statement

### expression
```cpp
10
x
x + 5
f(x)
++x
x++
f(x) > g(x)
x * x + y * y + z * z // in here x * x is named as subexpression.
```
In C++ every expression has a data type and a value category(L value expr., R value expr.).
Knowing the value category is critically important.

L value expressions point to an object
```cpp
int* p = &x;
*p;     // here *p is an L value expression
p;      // here p is also an L value expression
```

### Some R value expressions in C, are L value expressions in C++.
|                  | C |C++                         |
|------------------|---|:--------------------------:|
|++x               | R |L                           |
|--x               | R |L                           |
|assignment        | R |L                           |
|comma(,)          | R |(depending on the scenario)L|
|ternary           | R |(depending on the scenario)L|


## Value Categories in C++

### Primary Value Categories
- PR value    (Pure R value)
- L  value
- X  value    (eXpired value)

### Combined Value Categories
- PR&nbsp;&nbsp;∪&nbsp;&nbsp;X&nbsp;&nbsp;R Value
- L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∪&nbsp;&nbsp;X&nbsp;&nbsp;GL Value

## Upcoming Subjects in the Course
- Reference Semantics
- Default Argument's
- Type Deduction
    - Auto Type Deduction
    - Decltype Type Deduction
    - Scoped Enums
    - Type-Cast Operators
- Function Overloading
- Classes

## References
References are alternatives to pointers on a language level

- Call by Reference   : Functions work on the object directly.
- Call by Value       : Functions take a copy of the object and work on that copy.

In C to use call by reference we use pointers, in C++ we can use references in addition to pointers.

### Reference Categories
- L value     reference       (left  side reference)
- R value     reference       (right side reference)
- forwarding  reference       (universal  reference)
```cpp
int&   r = x;               // L value reference
int&&  r = x;               // R value reference
auto&& r = 10;              // universal reference
```
## Static Lifetime Variables
1. Globally defined variables
2. Local variables defined with static keyword
3. char arrays that were generated by the compiler corresponding to the char literals

## Initialization Types
```cpp
int x;          // Default  Initialization
int x = 10;     // Copy     Initialization
int x(10);      // Direct   Initialization
int x{10};      // Uniform  Initialization, also called brace initialization. Officially Direct List Initialization.
int x();        // Value    Initialization
int x{};        // Value    Initialization
```

###REMARK###
```cpp
double dval = 5.6;
int    ival = dval; // In this assignment there is a data loss and an implicit type conversion (from double to int).
                    // Conversions that cause data loss are called Narrowing Conversion.
```

 ###REMARK### Narrowing implicit conversion in a uniform initialization is a syntax error.
```cpp
double dval = 5.6;
int    ival{dval};     // This is a syntax error.
```

###REMARK### Const variables cannot be default initialized.

###REMARK### 0 and `nullptr` are different. But in C++ there is `nullptr`.
```cpp
int* ptr;
ptr = 0;                    // Implicit conversion from 0 to nullptr.
if(ptr == 0)                // Implicit conversion from 0 to nullptr. So it's the same as if(ptr == nullptr)
    std::cout << "true\n";  // true is the output.
```

`nullptr` is a
- Keyword.
- Constant.
- It's type is `nullptr_t`.
