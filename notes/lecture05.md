# LECTURE 05
## Reference Semantics

On language level, a reference and a pointer are the same thing, only difference is on the syntax level.<br>

There are three types of references.
1. L Value Reference
2. R Value Reference<br>
    used for
    - Move Semantics
    - Perfect Forwarding(is a tool related to generic programming)
3. Forwarding Reference (Universal Reference)

### How to use references and pointers on arrays?
```cpp
int  a[5]{0, 1, 2, 3, 4};
int& r1     = a[0]; // Here r1 is a reference to the first element of a.
int(&r2)[5] = a;    // Here r2 is a reference to the array itself.
// same goes for pointers
int* p1     = a; // Here p1 points to the first element of a.
int(*p2)[5] = &a; // Here p2 points to the array itself.
```

##### ###REMARK###
> ```cpp
> int  a   = 5;
> int& r_a = a;           // Data type of r_a is int& but the type of expression "r_a" is int.
> ```

### Why Do We Use L Value Reference?
For the %99 of the time;
- To pass an object to a function as call by reference
- bir fonksiyonun kendisini �a��ran koda bir nesnenin kendisini g�ndermesi

##### ###REMARK###
> ```cpp
> int* g;
> int* foo() {
>     return g;
> }
> 
> int main() {
>     int*& r = foo();    // This is a syntax error because foo() is an R value expression.
>     return 0;
> }
> ```

##### ###REMARK###
> Returning the address of an automatic lifetime variable is an undefined behaviour.

```cpp
void func1(T* x);        // setter-mutator
void func2(T const* x);  // getter-accessor
```

##### ###REMARK###
> ```cpp
> int           x  = 10;
> int&          r1 = x;     // VALID
> int&          r2 = 5;     // INVALID  Here r2 is bound to a temporary object generated by the compiler.
> int&&         r3 = x;     // INVALID
> int&&         r4 = 5;     // VALID
> int const&    r5 = 10;    // VALID    Here r5 is bound to a temporary object generated by the compiler.
> int const&&   r6 = x;     // VALID    But in practice int const&& is not a tool used or is it INVALID?
> double&       r7 = x;     // INVALID
> double const& r8 = x;     // VALID    Here r8 is bound to a temporary object generated by the compiler.
> ```

|                POINTERS                |                REFERENCES                |
|----------------------------------------|------------------------------------------|
|Default initialization is possible      |Default initialization is not possible|
|Dointer to pointer exists               |Reference to reference does not exist(there is reference collapsing)|
|Array with pointer elements exists      |Array with reference elements does not exist|
|Pointer to function exists              |Reference to function exists|
|Can be nullptr                          |No null reference|
|Can point to a different object         |Cannot be bound to a different object (std::reference_wrapper allows this)|

##### ###REMARK###
> ```cpp
> int&  r1;     // L value reference
> int&& r2;     // R value reference
> ```

## Type Deduction
There are four different type deductions mechanisms;
1. `auto`
2. `decltype()`
3. `decltype(auto)`
4. &nbsp;template

##### ###REMARK###
> Type deduction happens in compile time, it has nothing to do with run time.

### `auto` Type Deduction
- Variables defined with auto keyword must be initialized.
- Type deduction happens for auto keyword, not the type of variable. Meaning compiler determines what's written instead of
the `auto` keyword.
> ```cpp
> auto      x  = 5;     // Here compiler reads this line as if it was int x = 5, so `auto` = `int`.
> auto      p1 = &x;    // Here compiler reads this line as if it was int* p = &x, so auto = int*.
> auto*     p2 = &x;    // Here compiler reads this line as if it was int* p2 = &x, so auto = int.
> int const y  = 5;
> auto      x2 = y;     // Here const is lost, so compiler reads this line as if it was int x2 = y.
>                       // To keep the const it must be changed to auto const x2 = y.
> int       x  = 10;
> int&      r  = x;
> auto      y  = r;     // Here & is lost, so the compiler reads this line as if it was int y = r not int& y = r.
> ```
##### ###REMARK###
If pointers are used in `auto` initializations, low level `const` is not lost but top level `const` is lost.
-   ```cpp
    int const x[] = {0, 1, 2, 3, 4};
    auto      y   = x;      // As if it is int const* y = x, so auto = int const*.
    ```
-   ```cpp
    int const x = 5;
    auto      y = &x;       // As if it is int const * y = &x, so auto = int const*.
    ```

-   ```cpp
    int const x = 5;
    auto*     y = &x;       // As if it is int const* y = &x, so auto = int const.
    ```

-   ```cpp
    int const x = 5;
    auto&     y = x;        // As if it is int cosnt& y = x, so auto = int const.
    ```

-   ```cpp
    int const x[5]{};
    auto      y = &x;       // As if it is int const(*y)[5] = &x, so auto = int const(*)[5].
    ```

-   ```cpp
    int const x[5]{};
    auto&     y = x;        // As if it is int const(&y)[5] = x, so auto = int const[5].
    ```

-   ```cpp
    auto& y = "michael";    // As if it is char const(&y)[8] = "michael", so auto = char const[8].
    ```
    > All in the above examples, y is a const.

-   ```cpp
    int* const ptr{};
    auto       p = ptr;     // As if it is int* p = ptr, so auto = int*.
    ```

##### ###REMARK###
- Can also be for function pointers.
    > ```cpp
    > int foo(int);
    > 
    > int main() {
    >     auto x1 = foo();    // As if it is int(*x1)(int) = foo, so auto = int(*)(int).
    >     auto x2 = foo();    // Exactly same with the line above.
    >     auto x3 = &x1;      // As if it is int(**x3)(int) = foo, so auto = int(**)(int).
    >     return 0;
    > }
    > ```

### Reference Collapsing

| From | To | Result |                    Description                    |
|:----:|:--:|:------:|:-------------------------------------------------:|
|T&    |&   |T&      |L-val-ref to an L-val-ref collapses to an L-val-ref|
|T&    |&&  |T&      |L-val-ref to an R-val-ref collapses to an L-val-ref|
|T&&   |&   |T&      |R-val-ref to an L-val-ref collapses to an L-val-ref|
|T&&   |&&  |T&&     |R-val-ref to an R-val-ref collapses to an R-val-ref|
> ```cpp
> using lref = int&;
> using rref = int&&;
> int    x   = 10;
> auto&& p   = x;   // As if it is int& && p = x, so auto = int&. By reference collapsing int& && becomes int&.
> lref&  y   = x;   // int&  &   by reference collapsing becomes int&.
> lref&& y   = x;   // int&  &&  by reference collapsing becomes int&.
> rref&  y   = x;   // int&& &   by reference collapsing becomes int&.
> rref&& z   = z;   // int&& &&  by reference collapsing becomes int&&.
> ```

### Universal Reference (Forwarding Reference) (`auto&& name = expression`)
- If the `expression` is L value expression then, auto = T&.
- If the `expression` is R value expression then, auto = T.
```cpp
int    x  = 10;
auto&& r1 = x;      // As if it is int&  r1 = x, so auto = int&.
auto&& r2 = 10;     // As if it is int&& r2 = 10, so auto = int.
```

##### ###REMARK###
`auto` keyword can be used in comma seprated list declarations but deduction for `auto` for all the variables must be the same.
```cpp
auto  x = 10,  y = 5;   // As if it is int x = 10, y = 5, so auto = int.
auto *z = &x,  t = y;   // This is legal because for both variables auto is deduced to int.
auto  a = 10., b = 5;   // This is a syntax error because auto for x is double but for y it's int.
```
