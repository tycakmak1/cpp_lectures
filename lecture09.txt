=============================================LECTURE 09=============================================
====================================================================================================

====================================================================================================
constexpr Keyword
    const and constexpr are different from each other
        If a const variable defined with a constant expression(e.g. int x = 5, 5 here is the
        constant expression), then expression generated by the variable is constexpr.
        If it's initialized with a variable expression than the expression generated by the variable
        is not constexpr.
            e.g.
                int const x = 5;
                int const y = foo();    // foo is a function that returns int
                int arr1[x]{};          // Is valid because here the expression x is constexpr.
                int arr2[y]{};          // Is invalid because here the expression y is not constexpr
                                        // and compiler has to know the size of the array at the
                                        // compile time. This is about variable length array.

    constexpr Keyword
        constexpr int x = 10;           // When constexpr used in declaration, we must use a
                                        // constant expression to initialize the variable.

    ###REMARK###
        int const a = 5;                // Declaration type(value type) of a is int const.
        constexpr int b = 5;            // Declaration type(value type) of b is int const.
    ###REMARK###

    ###REMARK###
        constexpr creates a top level const.
            e.g.
                int g = 10;
                constexpr int* p1 = &g;         // p1 is a const pointer to an int.
                constexpr int const* p2 = &g;   // p2 is a const pointer to int const. This can be
                                                // done if the rhs of "=" is known at the compile
                                                // time.
    ###REMARK###

    ###REMARK###
        Expressions generated by variables defined with const keyword, may or may not generate a
        constant expression, but expressions generated by variables defined with constexpr keyword,
        always generate a constant expression.
    ###REMARK###

    constexpr Functions
        they exist mainly because of efficiency reasons. they are implicitly inline.

        ###REMARK###
            constexpr functions cannot have static variables defined in them.
        ###REMARK###

        For a function to be defined as constexpr function it must be;
            1-) It's return type
            2-) Types of it's parameters
            3-) Types of it's local variables

            all must be literal types. arithmetic types, pointer types are literal types.    
            For a class to be a literal type there are conditions it must satisfy(topic for later).

    Arrays can also be constexpr.
        e.g.
            constexpr int primes[] = {2, 3, 5, 7};
            constexpr int a = primes[2];

====================================================================================================
Classes
    Class Definition
        // Data Members
        // Member Functions
        // Type Member / Member Type / Nested Type
        
    Class Members
        Data Members
            Non-Static Data Members
            Static Data Members
        Member Functions
            Non-Static Member Function
            Static Member Function    
        Type Members

    Classes have access control;
        - public
        - private
        - protected

    Name Lookup
    Context Control
    Access Control
    
    class Myclass
    {
    public:
        void foo();         // Non-static member function.
        static void bar();  // Static      member function.
        ###REMARK###
            Non-static member functions have a hidden parameter. Which is pointer of the instance
            that they belong to. For this example it is Myclass*, so void foo() is actually
            void foo(Myclass*).
        ###REMARK###
    private:
        int _x;             // Non-static data member.
        static int _y;      // Static     data member.
    }
    
    MyClass mc;
    mc._x                   // Dot operator.
    &mc->_x                 // Arrow operator.
    MyClass::_y             // Scope resolution operator.
    
    ###REMARK###
        Access modifiers do not create different scopes or affect scopes in any way.
    ###REMARK###
    
    ###REMARK###
        Memory location of data members of a class may or may not be the same with their declaration
        order. This is implementation defined(compiler dependent).
    ###REMARK###
    
    If a function is part of a class then it is called a member function,
    If it belongs to the global scope then it is called global function or free function or
    stand-alone function.
====================================================================================================
